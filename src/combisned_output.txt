=== ./app.d.ts ===
import "unplugin-icons/types/svelte";

// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
  namespace App {
    // interface Error {}
    // interface Locals {}
    // interface PageData {}
    // interface PageState {}
    // interface Platform {}
  }
}

export {};
-e

=== ./lib/p5/types/sketch.ts ===
import type p5 from "p5";

export interface Point {
  x: number;
  y: number;
  time: number;
  pathId: number;
}

export interface P5State {
  videoElement: p5.Element | null;
  imageElement: p5.Element | null;
  drawingPoints: Point[];
  isDrawing: boolean;
  currentPathId: number;
}
-e

=== ./lib/p5/features/video.ts ===
import type p5 from "p5";
import { drawingState } from "../../stores/drawingState";
import { get } from "svelte/store";
import { drawingConfig } from "../../stores/drawingConfig";

export function setupVideo(p5: p5) {
  const setVideo = (video: HTMLVideoElement) => {
    const p5Vid = p5.createVideo([video.src]);

    p5Vid.hide();

    p5Vid.elt.onplay = () =>
      drawingState.update((state) => ({ ...state, isVideoPlaying: true }));
    p5Vid.elt.onpause = () =>
      drawingState.update((state) => ({ ...state, isVideoPlaying: false }));

    return p5Vid;
  };

  const updateVideoTime = (videoElement: p5.Element, lastVideoTime: number) => {
    if (videoElement) {
      const currentTime = (videoElement as any).elt.currentTime;
      if (currentTime !== lastVideoTime) {
        drawingState.update((state) => ({ ...state, videoTime: currentTime }));
        return currentTime;
      }
    }
    return lastVideoTime;
  };

  const drawVideo = (p5: p5, videoElement: p5.Element) => {
    const config = get(drawingConfig);
    const splitX = (p5.width * config.splitPosition) / 100;
    const aspectRatio =
      videoElement.elt.videoWidth / videoElement.elt.videoHeight;
    const displayHeight = Math.min(p5.height, splitX / aspectRatio);
    const yOffset = (p5.height - displayHeight) / 2;

    p5.image(videoElement, 0, yOffset, splitX, displayHeight);
  };

  return {
    setVideo,
    updateVideoTime,
    drawVideo,
  };
}
-e

=== ./lib/p5/features/drawing.ts ===
import type p5 from "p5";
import type { Point } from "../types/sketch";
import { get } from "svelte/store";
import {
  drawingState,
  addPointToCurrentPath,
  toggleDrawing,
} from "../../stores/drawingState";
import { drawingConfig } from "../../stores/drawingConfig";
import {
  isInDrawableArea,
  convertToImageCoordinates,
} from "../../utils/drawingUtils";

class TimeBasedSampler {
  private lastSampleTime: number = 0;

  constructor(private sampleInterval: number) {}

  shouldSample(currentTime: number): boolean {
    if (currentTime - this.lastSampleTime >= this.sampleInterval) {
      this.lastSampleTime = currentTime;
      return true;
    }
    return false;
  }

  reset() {
    this.lastSampleTime = 0;
  }
}

export function setupDrawing(p5: p5) {
  const sampler = new TimeBasedSampler(get(drawingConfig).pollingRate / 1000);

  drawingConfig.subscribe((config) => {
    sampler.reset();
  });

  const addCurrentPoint = () => {
    const state = get(drawingState);
    if (!state.shouldTrackMouse) return;

    if (isInDrawableArea(p5, p5.mouseX, p5.mouseY)) {
      if (sampler.shouldSample(state.videoTime)) {
        const coords = convertToImageCoordinates(p5, p5.mouseX, p5.mouseY);
        const point: Point = {
          ...coords,
          time: state.videoTime,
          pathId: state.currentPathId,
        };
        addPointToCurrentPath(point);
      }
    }
  };

  const handleMousePressed = (videoElement?: HTMLVideoElement) => {
    if (isInDrawableArea(p5, p5.mouseX, p5.mouseY)) {
      if (!get(drawingState).shouldTrackMouse) {
        sampler.reset();
      }
      toggleDrawing(videoElement);
    }
  };

  const handleDrawing = () => {
    const state = get(drawingState);
    if (state.shouldTrackMouse) {
      addCurrentPoint();
    }
  };

  return {
    handleMousePressed,
    handleDrawing,
  };
}

export function drawPaths(p5: p5) {
  const state = get(drawingState);
  const config = get(drawingConfig);
  const splitX = (p5.width * config.splitPosition) / 100;
  const drawingAreaWidth = p5.width - splitX;
  const drawingAreaHeight = p5.height;
  const ENDPOINT_MARKER_SIZE = 15;

  p5.push();

  state.paths.forEach((path) => {
    p5.strokeWeight(config.strokeWeight);
    p5.stroke(path.color);
    p5.noFill();

    if (path.points.length > 1) {
      p5.beginShape();
      path.points.forEach((point) => {
        const displayX =
          splitX + (point.x * drawingAreaWidth) / state.imageWidth;
        const displayY = (point.y * drawingAreaHeight) / state.imageHeight;
        p5.vertex(displayX, displayY);
      });
      p5.endShape();

      if (path.pathId === state.currentPathId && !state.shouldTrackMouse) {
        const lastPoint = path.points[path.points.length - 1];
        const displayX =
          splitX + (lastPoint.x * drawingAreaWidth) / state.imageWidth;
        const displayY = (lastPoint.y * drawingAreaHeight) / state.imageHeight;

        const pulseScale = (Math.sin(p5.frameCount * 0.05) + 1) * 0.25 + 0.5;

        p5.noStroke();
        for (let i = 4; i > 0; i--) {
          const alpha = 50 - i * 10;
          p5.fill(255, 0, 0, alpha);
          const size = ENDPOINT_MARKER_SIZE * (1.5 + i * 0.5) * pulseScale;
          p5.circle(displayX, displayY, size);
        }

        p5.fill(255, 0, 0, 200);
        p5.circle(displayX, displayY, ENDPOINT_MARKER_SIZE * pulseScale);

        p5.fill(255);
        p5.circle(displayX, displayY, ENDPOINT_MARKER_SIZE * 0.5 * pulseScale);
      }
    } else if (path.points.length === 1) {
      const point = path.points[0];
      const displayX = splitX + (point.x * drawingAreaWidth) / state.imageWidth;
      const displayY = (point.y * drawingAreaHeight) / state.imageHeight;
      p5.point(displayX, displayY);
    }
  });

  p5.pop();
}
-e

=== ./lib/utils/drawingUtils.ts ===
import type p5 from "p5";
import { get } from "svelte/store";
import { drawingConfig } from "../stores/drawingConfig";
import { drawingState } from "../stores/drawingState";

export function isInDrawableArea(p5: p5, x: number, y: number): boolean {
  const config = get(drawingConfig);
  const splitX = (p5.width * config.splitPosition) / 100;

  return x > splitX && x < p5.width && y > 0 && y < p5.height;
}

export function convertToImageCoordinates(p5: p5, x: number, y: number) {
  const config = get(drawingConfig);
  const state = get(drawingState);
  const splitX = (p5.width * config.splitPosition) / 100;

  const constrainedX = p5.constrain(x, splitX, p5.width);
  const constrainedY = p5.constrain(y, 0, p5.height);

  const drawingAreaWidth = p5.width - splitX;
  const drawingAreaHeight = p5.height;

  const imageX =
    ((constrainedX - splitX) * state.imageWidth) / drawingAreaWidth;
  const imageY = (constrainedY * state.imageHeight) / drawingAreaHeight;

  return {
    x: imageX,
    y: imageY,
  };
}
-e

=== ./lib/stores/drawingState.ts ===
import { writable } from "svelte/store";
import type p5 from "p5";
import type { Point } from "../p5/types/sketch";

export interface PathData {
  points: Point[];
  color: string;
  pathId: number;
}

export interface DrawingState {
  isVideoPlaying: boolean;
  isDrawing: boolean;
  shouldTrackMouse: boolean;
  paths: PathData[];
  imageWidth: number;
  imageHeight: number;
  videoTime: number;
  imageElement: p5.Image | null;
  currentPathId: number;
  isJumping: boolean;
}

const initialState: DrawingState = {
  isVideoPlaying: false,
  isDrawing: false,
  shouldTrackMouse: false,
  paths: [],
  imageWidth: 0,
  imageHeight: 0,
  videoTime: 0,
  imageElement: null,
  currentPathId: 0,
  isJumping: false,
};

const JUMP_SECONDS = 5;
const JUMP_COOLDOWN = 250;

export function handleTimeJump(
  forward: boolean,
  videoElement?: HTMLVideoElement
) {
  drawingState.update((state) => {
    if (state.isJumping || !videoElement) return state;

    const currentTime = state.videoTime;
    let newTime: number;

    if (forward) {
      // Fast forward
      newTime = Math.min(currentTime + JUMP_SECONDS, videoElement.duration);
      videoElement.currentTime = newTime;

      // Find current path
      const currentPathIndex = state.paths.findIndex(
        (p) => p.pathId === state.currentPathId
      );
      if (currentPathIndex === -1) return state;

      const updatedPaths = [...state.paths];
      const currentPath = updatedPaths[currentPathIndex];

      // Get the last point before the jump
      const lastPoint = currentPath.points[currentPath.points.length - 1];
      if (!lastPoint) return state;

      // Add points at regular intervals during the jump
      const samplingRate = get(drawingConfig).pollingRate / 1000; // Convert to seconds
      const updatedPoints = [...currentPath.points];

      for (
        let t = currentTime + samplingRate;
        t <= newTime;
        t += samplingRate
      ) {
        updatedPoints.push({
          x: lastPoint.x,
          y: lastPoint.y,
          time: t,
          pathId: state.currentPathId,
        });
      }

      updatedPaths[currentPathIndex] = {
        ...currentPath,
        points: updatedPoints,
      };

      return {
        ...state,
        isJumping: true,
        videoTime: newTime,
        paths: updatedPaths,
      };
    } else {
      newTime = Math.max(currentTime - JUMP_SECONDS, 0);
      videoElement.currentTime = newTime;

      const currentPathIndex = state.paths.findIndex(
        (p) => p.pathId === state.currentPathId
      );
      if (currentPathIndex === -1) return state;

      const updatedPaths = [...state.paths];
      const currentPath = updatedPaths[currentPathIndex];

      const updatedPoints = currentPath.points.filter(
        (point) => point.time <= newTime
      );
      updatedPaths[currentPathIndex] = {
        ...currentPath,
        points: updatedPoints,
      };

      if (state.shouldTrackMouse) {
        videoElement.pause();
      }

      return {
        ...state,
        isJumping: true,
        shouldTrackMouse: false,
        isDrawing: false,
        isVideoPlaying: false,
        videoTime: newTime,
        paths: updatedPaths,
      };
    }
  });

  setTimeout(() => {
    drawingState.update((state) => ({
      ...state,
      isJumping: false,
    }));
  }, JUMP_COOLDOWN);
}

export const drawingState = writable<DrawingState>(initialState);

export function toggleDrawing(videoElement?: HTMLVideoElement) {
  drawingState.update((state) => {
    const newShouldTrack = !state.shouldTrackMouse;

    if (videoElement) {
      try {
        if (newShouldTrack) {
          const playPromise = videoElement.play();
          if (playPromise !== undefined) {
            playPromise.catch((error) => {
              console.error("Error playing video:", error);
            });
          }
        } else {
          videoElement.pause();
        }
      } catch (error) {
        console.error("Error handling video:", error);
      }
    }

    return {
      ...state,
      shouldTrackMouse: newShouldTrack,
      isDrawing: newShouldTrack,
      isVideoPlaying: newShouldTrack,
    };
  });
}

export function createNewPath(color: string) {
  drawingState.update((state) => {
    const newPathId = state.currentPathId + 1;
    return {
      ...state,
      currentPathId: newPathId,
      paths: [
        ...state.paths,
        {
          points: [],
          color,
          pathId: newPathId,
        },
      ],
    };
  });
}

export function addPointToCurrentPath(point: Point) {
  drawingState.update((state) => {
    if (!state.shouldTrackMouse) return state;

    const currentPathIndex = state.paths.findIndex(
      (p) => p.pathId === state.currentPathId
    );

    if (currentPathIndex === -1) {
      const colors = [
        "#FF0000",
        "#00FF00",
        "#0000FF",
        "#FFFF00",
        "#FF00FF",
        "#00FFFF",
      ];
      const newColor = colors[state.paths.length % colors.length];
      createNewPath(newColor);
      return state;
    }

    const updatedPaths = [...state.paths];
    updatedPaths[currentPathIndex] = {
      ...updatedPaths[currentPathIndex],
      points: [...updatedPaths[currentPathIndex].points, point],
    };

    return {
      ...state,
      paths: updatedPaths,
    };
  });
}
-e

=== ./lib/stores/drawingConfig.ts ===
import { writable } from "svelte/store";

interface DrawingConfig {
  strokeWeight: number;
  strokeColor: string;
  splitPosition: number; // percentage (0-100)
  pollingRate: number; // milliseconds
}

const defaultConfig: DrawingConfig = {
  strokeWeight: 5,
  strokeColor: "#000000",
  splitPosition: 50,
  pollingRate: 16,
};

export const drawingConfig = writable<DrawingConfig>(defaultConfig);

export const updateStrokeWeight = (weight: number) => {
  drawingConfig.update((config) => ({ ...config, strokeWeight: weight }));
};

export const updateStrokeColor = (color: string) => {
  drawingConfig.update((config) => ({ ...config, strokeColor: color }));
};

export const updateSplitPosition = (position: number) => {
  drawingConfig.update((config) => ({ ...config, splitPosition: position }));
};

export const updatePollingRate = (rate: number) => {
  drawingConfig.update((config) => ({ ...config, pollingRate: rate }));
};
-e



=== ./routes/+page.svelte ===
<script lang="ts">
  import P5Wrapper from '../lib/p5/P5Wrapper.svelte';
  import Navbar from '$lib/components/nav/Navbar.svelte';

  let p5Component: P5Wrapper;

  function handleVideoUpload(event: Event) {
    const file = (event.target as HTMLInputElement).files?.[0];
    if (file) {
      const video = document.createElement('video');
      video.src = URL.createObjectURL(file);
      video.autoplay = false;
      video.loop = false;
      p5Component.setVideo(video);
    }
  }

  function handleImageUpload(event: Event) {
    const file = (event.target as HTMLInputElement).files?.[0];
    if (file) {
      const image = new Image();
      image.src = URL.createObjectURL(file);
      image.onload = () => p5Component.setImage(image);
    }
  }

  function handleSavePath() {
    p5Component.exportPath();
  }

  function handleClear() {
    p5Component.clearDrawing();
  }

  function handleNewPath() {
    p5Component.startNewPath();
  }
</script>

<Navbar
  onImageUpload={handleImageUpload}
  onVideoUpload={handleVideoUpload}
  onSavePath={handleSavePath}
  onClear={handleClear}
  onNewPath={handleNewPath}
/>
<P5Wrapper bind:this={p5Component} />-e

=== ./routes/+layout.svelte ===
<script>
  import "tailwindcss/tailwind.css";
</script>

<slot />-e

=== ./lib/p5/P5Wrapper.svelte ===
<script lang="ts">
  import P5, { type Sketch } from 'p5-svelte';
  import type p5 from 'p5';
  import { onMount } from 'svelte';
  import { drawingConfig } from '../stores/drawingConfig';
  import { drawingState, createNewPath, handleTimeJump } from '../stores/drawingState';
  import { setupDrawing, drawPaths } from './features/drawing';
  import { setupVideo } from './features/video';
  import VideoControls from '../components/video/VideoControls.svelte';

  let containerDiv: HTMLDivElement;
  let width = 800;
  let height = 400;
  let isDraggingSplitter = false;
  let videoElement: p5.Element | null = null;
  let p5Instance: p5;
  let lastVideoTime = 0;
  const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];

  $: videoHtmlElement = videoElement ? (videoElement as any).elt : null;

  function handleSplitterDrag(e: MouseEvent) {
    if (isDraggingSplitter) {
      e.preventDefault();
      e.stopPropagation();

      const rect = containerDiv.getBoundingClientRect();
      const position = ((e.clientX - rect.left) / rect.width) * 100;
      const minVideoWidth = 30;
      const minImageWidth = 30;
      const constrainedPosition = Math.min(
        Math.max(position, minVideoWidth),
        100 - minImageWidth
      );

      drawingConfig.update(config => ({
        ...config,
        splitPosition: constrainedPosition
      }));

      if (p5Instance) {
        p5Instance.noLoop();
      }
    }
  }

  onMount(() => {
    window.addEventListener('keydown', (e) => {
      if (!videoHtmlElement) return;

      if (e.code === 'Space') {
        e.preventDefault();
        if (videoHtmlElement.paused) {
          videoHtmlElement.play();
        } else {
          videoHtmlElement.pause();
        }
      } else if (e.key.toLowerCase() === 'f') {
        e.preventDefault();
        handleTimeJump(true, videoHtmlElement);
      } else if (e.key.toLowerCase() === 'r') {
        e.preventDefault();
        handleTimeJump(false, videoHtmlElement);
      }
    });

    const updateDimensions = () => {
      height = window.innerHeight - 64;
      width = containerDiv.clientWidth;
      if (p5Instance) {
        p5Instance.resizeCanvas(width, height);
      }
    };

    window.addEventListener('resize', updateDimensions);
    updateDimensions();
    return () => window.removeEventListener('resize', updateDimensions);
  });

  const sketch: Sketch = (p5: p5) => {
    p5Instance = p5;
    const { handleMousePressed, handleDrawing } = setupDrawing(p5);

    p5.setup = () => {
      const canvas = p5.createCanvas(width, height);
      canvas.parent(containerDiv);
      p5.strokeCap(p5.ROUND);
      p5.strokeJoin(p5.ROUND);
    };

    p5.draw = () => {
      p5.background(255);
      const splitX = (width * $drawingConfig.splitPosition) / 100;

      if (videoElement) {
        const { updateVideoTime, drawVideo } = setupVideo(p5);
        lastVideoTime = updateVideoTime(videoElement, lastVideoTime);
        drawVideo(p5, videoElement);
      }

      const currentImage = $drawingState.imageElement;
      if (currentImage && $drawingState.imageWidth > 0) {
        const aspectRatio = $drawingState.imageWidth / $drawingState.imageHeight;
        const displayHeight = Math.min(height, (width - splitX) / aspectRatio);
        p5.image(currentImage, splitX, 0, width - splitX, displayHeight);
      }

      handleDrawing();
      drawPaths(p5);
    };

    p5.mousePressed = () => {
      if (!isDraggingSplitter) {
        handleMousePressed(videoHtmlElement);
      }
    };

    if (p5Instance) {
      p5Instance.loop();
    }
  };

  export function setVideo(video: HTMLVideoElement) {
    if (videoElement) {
      (videoElement as any).remove();
    }
    const { setVideo: setupP5Video } = setupVideo(p5Instance);
    videoElement = setupP5Video(video);

    createNewPath(colors[0]);
  }

  export function setImage(image: HTMLImageElement) {
    p5Instance.loadImage(image.src, (p5Img: p5.Image) => {
      drawingState.update(state => ({
        ...state,
        imageWidth: image.width,
        imageHeight: image.height,
        imageElement: p5Img
      }));
    });
  }

  export function startNewPath() {
    if (videoHtmlElement) {
      videoHtmlElement.currentTime = 0;
      videoHtmlElement.pause();
      const currentPathCount = $drawingState.paths.length;
      const newColor = colors[currentPathCount % colors.length];
      createNewPath(newColor);
    }
  }

  export function exportPath() {
    const paths = $drawingState.paths;
    paths.forEach((path, index) => {
      // Make sure we have points to export
      if (path.points.length === 0) return;

      // Format CSV data
      const csv = path.points.map(p => `${p.x},${p.y},${p.time}`).join('\n');
      const blob = new Blob([`x,y,time\n${csv}`], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);

      // Create and trigger download
      const a = document.createElement('a');
      a.href = url;
      a.download = `path-${index + 1}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      // Clean up the URL
      URL.revokeObjectURL(url);
    });
  }

  export function clearDrawing() {
    if (videoHtmlElement) {
      videoHtmlElement.currentTime = 0;
      videoHtmlElement.pause();
    }

    drawingState.update(state => ({
      ...state,
      paths: [],
      currentPathId: 0
    }));

    createNewPath(colors[0]);
  }

  $: if (containerDiv && $drawingConfig) {
    containerDiv.style.setProperty('--split-width', `${$drawingConfig.splitPosition}%`);
  }
</script>

<div
  bind:this={containerDiv}
  class="relative w-full h-[calc(100vh-64px)]"
  on:mousemove={handleSplitterDrag}
  on:mouseup={() => isDraggingSplitter = false}
  on:mouseleave={() => isDraggingSplitter = false}
  role="application"
  aria-label="Drawing Canvas"
>
  <P5 {sketch} />

  <div
    class="absolute top-0 bottom-0 w-8 bg-transparent cursor-col-resize hover:bg-black/5"
    style="left: calc({$drawingConfig.splitPosition}% - 16px)"
    on:mousedown={(e) => {
      e.preventDefault();
      e.stopPropagation();
      isDraggingSplitter = true;
    }}
    role="separator"
    aria-label="Resize panels"
  >
    <div
      class="absolute top-0 bottom-0 w-1 bg-gray-400 hover:bg-blue-500 transition-colors"
      style="left: 50%"
    />
  </div>

  {#if videoHtmlElement}
    <VideoControls videoElement={videoHtmlElement} />
  {/if}
</div>-e

=== ./lib/components/nav/Navbar.svelte ===
<script lang="ts">
  import IconHelp from '~icons/material-symbols/help-outline';
  import IconSettings from '~icons/material-symbols/settings';
  import IconUpload from '~icons/material-symbols/upload';
  import IconDelete from '~icons/material-symbols/delete-outline';
  import IconExport from '~icons/material-symbols/download';
  import { drawingConfig } from '$lib/stores/drawingConfig';

  export let onImageUpload: (event: Event) => void;
  export let onVideoUpload: (event: Event) => void;
  export let onSavePath: () => void;
  export let onClear: () => void;
  export let onNewPath: () => void;

  const strokeWeights = [1, 2, 3, 4, 5, 8, 10];
  const pollingRates = [
    { label: '4ms', value: 4 },
    { label: '8ms', value: 8 },
    { label: '16ms', value: 16 },
    { label: '32ms', value: 32 },
    { label: '64ms', value: 64 },
    { label: '100ms', value: 100 },
  ];

  function handleFileUpload(event: Event) {
    const file = (event.target as HTMLInputElement).files?.[0];
    if (!file) return;

    if (file.type.startsWith('video/')) {
      onVideoUpload(event);
    } else if (file.type.startsWith('image/')) {
      onImageUpload(event);
    } else {
      alert('Please upload a video or image file');
    }

    (event.target as HTMLInputElement).value = '';
  }

  function preventDrawing(e: MouseEvent) {
    e.stopPropagation();
  }

  function openHelpModal() {
    const modal = document.getElementById('help_modal');
    if (modal instanceof HTMLDialogElement) {
      modal.showModal();
    }
  }
</script>

<div class="navbar bg-base-100 h-16" on:mousedown={preventDrawing} on:mouseup={preventDrawing} on:mousemove={preventDrawing}>
  <div class="flex-1">
    <a class="btn btn-ghost text-xl">Mondrian</a>
  </div>
  <div class="flex justify-end items-center gap-2">
    <!-- Help -->
    <button class="btn btn-ghost" on:click={openHelpModal}>
      <IconHelp class="w-5 h-5" />
    </button>

    <!-- Clear All -->
    <button class="btn btn-ghost gap-2" on:click={onClear}>
      <IconDelete class="w-5 h-5" />
      Clear All
    </button>

    <!-- Export All -->
    <button class="btn btn-ghost gap-2" on:click={onSavePath}>
      <IconExport class="w-5 h-5" />
      Export All
    </button>

    <!-- File Upload -->
    <label class="btn btn-ghost gap-2">
      <IconUpload class="w-5 h-5" />
      Upload File
      <input
        type="file"
        class="hidden"
        accept="video/*,image/*"
        on:change={handleFileUpload}
      />
    </label>

    <!-- New Path -->
    <button class="btn btn-primary gap-2" on:click={onNewPath}>
      New Path
    </button>

    <!-- Settings Dropdown -->
    <div class="dropdown dropdown-end" on:click={preventDrawing}>
      <div tabindex="0" role="button" class="btn btn-ghost">
        <IconSettings class="w-5 h-5" />
      </div>
      <ul tabindex="0" class="dropdown-content menu bg-base-100 rounded-box z-[1] w-80 p-4 shadow mt-4">
        <li>
          <label class="label cursor-pointer flex-col items-start gap-2">
            <span class="label-text w-full">Point Capture Interval</span>
            <select
              class="select select-bordered select-sm w-full"
              value={$drawingConfig.pollingRate}
              on:change={(e) => drawingConfig.update(c => ({ ...c, pollingRate: parseInt(e.currentTarget.value) }))}
            >
              {#each pollingRates as rate}
                <option value={rate.value}>{rate.label}</option>
              {/each}
            </select>
          </label>
        </li>
        <li>
          <label class="label cursor-pointer flex-col items-start gap-2">
            <span class="label-text w-full">Stroke Weight</span>
            <select
              class="select select-bordered select-sm w-full"
              value={$drawingConfig.strokeWeight}
              on:change={(e) => drawingConfig.update(c => ({ ...c, strokeWeight: parseInt(e.currentTarget.value) }))}
            >
              {#each strokeWeights as weight}
                <option value={weight}>{weight}px</option>
              {/each}
            </select>
          </label>
        </li>
      </ul>
    </div>
  </div>
</div>

<dialog id="help_modal" class="modal">
  <div class="modal-box w-11/12 max-w-3xl">
    <h3 class="font-bold text-lg mb-4">Mondrian Transcription Software</h3>
    <p class="py-2">
      Hello! This is a tool to transcribe fine-grained movement data from video. To get started, use the top buttons to load a floor plan formatted as a PNG/JPG image and video formatted as a MP4 file.
    </p>
    <p class="py-2">
      Then, click once anywhere on the floor plan to start recording movement data synchronized to the video. As you move your cursor over the floor plan, positioning data is recorded. Play/pause recording by clicking on the floor plan. Press the 'f' key to fast forward and the 'r' key to rewind video and data recording in 5 second intervals. Use the top buttons to clear or save your recording data as a CSV file.
    </p>
    <p class="py-2">
      For further information, learn more about Mondrian Transcription
    </p>
    <p class="text-sm text-gray-500 mt-4 italic">
      Mondrian Transcription software is an open-source project built with JavaScript and p5.js licensed under the GNU General Public License Version 2.0. It is developed by Ben Rydal Shapiro and contributors with support from the National Science Foundation. Contribute | Reference
    </p>
    <div class="modal-action">
      <form method="dialog">
        <button class="btn">Close</button>
      </form>
    </div>
  </div>
  <form method="dialog" class="modal-backdrop">
    <button>close</button>
  </form>
</dialog>-e

=== ./lib/components/video/VideoControls.svelte ===
<script lang="ts">
  import { onMount } from 'svelte';

  export let videoElement: HTMLVideoElement;

  let progress = 0;
  let duration = 0;
  let currentTime = 0;
  let isDraggingProgress = false;
  let progressBarElement: HTMLProgressElement;

  onMount(() => {
    if (videoElement) {
      videoElement.addEventListener('timeupdate', updateProgress);
      videoElement.addEventListener('loadedmetadata', () => {
        duration = videoElement.duration;
      });
    }

    return () => {
      if (videoElement) {
        videoElement.removeEventListener('timeupdate', updateProgress);
      }
    };
  });

  function updateProgress() {
    if (!isDraggingProgress && videoElement) {
      progress = (videoElement.currentTime / videoElement.duration) * 100;
      currentTime = videoElement.currentTime;
    }
  }

  function handleProgressBarClick(e: MouseEvent) {
    if (!videoElement || !progressBarElement) return;

    const rect = progressBarElement.getBoundingClientRect();
    const pos = (e.clientX - rect.left) / rect.width;
    videoElement.currentTime = pos * videoElement.duration;
  }

  function handleProgressBarDrag(e: MouseEvent) {
    if (isDraggingProgress && progressBarElement) {
      handleProgressBarClick(e);
    }
  }

  function formatTime(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }
</script>

<div class="video-controls p-2 rounded-b-lg">
  <div class="w-full flex items-center">
    <progress
      bind:this={progressBarElement}
      class="progress progress-secondary flex-1 cursor-pointer"
      value={progress}
      max="100"
      on:mousedown={() => isDraggingProgress = true}
      on:mousemove={handleProgressBarDrag}
      on:mouseup={() => isDraggingProgress = false}
      on:mouseleave={() => isDraggingProgress = false}
      on:click={handleProgressBarClick}
    />
  </div>

  <div class="flex justify-between items-center mt-1 text-sm">
    <span>{formatTime(currentTime)}</span>
    <span>{formatTime(duration)}</span>
  </div>
</div>

<style>
  .video-controls {
    position: absolute;
    bottom: 0;
    left: 0;
    z-index: 10;
    width: var(--split-width);
  }

  progress:focus {
    outline: none;
  }
</style>-e

